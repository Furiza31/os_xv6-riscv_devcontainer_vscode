<!DOCTYPE html>
<html>
<head>
<title>report.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="compte-rendu">Compte Rendu</h1>
<p><strong>Nom</strong> : Hugo Wendjaneh, Louis Maury, Fouad Id Gouahmane
<strong>Date</strong> : 05-05-2025
<strong>Sujet</strong> : Systèmes d'exploitation - Communications inter-processus
<strong>Contexte</strong> : OS XV6 Risc V</p>
<h2 id="1-objectif">1. Objectif</h2>
<p>L'objectif de ce TP est d'explorer et de mettre en œuvre les mécanismes de communication inter-processus (IPC) dans un environnement Unix, en utilisant le système d'exploitation éducatif XV6. À travers différents exemples de programmes, nous allons étudier comment les processus peuvent communiquer entre eux grâce aux pipes, qui sont l'un des mécanismes fondamentaux d'IPC dans les systèmes de type Unix.</p>
<h2 id="2-tp-3-r%C3%A9alisation">2. TP 3: Réalisation</h2>
<h3 id="21-programme-ping-pong">2.1 Programme Ping Pong</h3>
<p>Ce programme démontre la communication bidirectionnelle entre un processus parent et son processus fils, en utilisant deux pipes, un pour chaque direction de communication. Le parent envoie &quot;ping&quot; et le fils répond avec &quot;pong&quot;.</p>
<h4 id="211-description-du-programme">2.1.1 Description du programme</h4>
<p>Le programme <code>pingpong</code> permet de créer deux processus qui s'échangent des messages &quot;ping&quot; et &quot;pong&quot; via des pipes. Le processus parent commence par envoyer un &quot;ping&quot; au processus fils, qui répond par un &quot;pong&quot;. Ce cycle se répète un nombre défini de fois (5 par défaut ou spécifié par l'utilisateur).</p>
<h4 id="212-impl%C3%A9mentation">2.1.2 Implémentation</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/types.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/stat.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"user/user.h"</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_PING_PONG 5</span>

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"Usage : pingpong &lt;number of pong&gt;. Default is 5\n"</span>);
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">is_number</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span>
</span>{
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">'\0'</span>; i++){
    <span class="hljs-keyword">if</span>(s[i] &lt; <span class="hljs-string">'0'</span> || s[i] &gt; <span class="hljs-string">'9'</span>){
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span>
</span>{
  <span class="hljs-keyword">int</span> number_of_ping_pong = MAX_PING_PONG;
  <span class="hljs-keyword">int</span> p1[<span class="hljs-number">2</span>], p2[<span class="hljs-number">2</span>];

  <span class="hljs-keyword">if</span>(argc &gt; <span class="hljs-number">2</span>){
    usage();
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">2</span>){
    <span class="hljs-keyword">if</span>(!is_number(argv[<span class="hljs-number">1</span>])){
      usage();
    }
    number_of_ping_pong = atoi(argv[<span class="hljs-number">1</span>]);
  }

  <span class="hljs-keyword">if</span>(pipe(p1) &lt; <span class="hljs-number">0</span> || pipe(p2) &lt; <span class="hljs-number">0</span>){
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"pipe error\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">int</span> pid = fork();

  <span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>){
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"fork error\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
  }

  <span class="hljs-comment">// Processus enfant</span>
  <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>){
    <span class="hljs-built_in">close</span>(p1[<span class="hljs-number">1</span>]); <span class="hljs-comment">// Ferme le write end de pipe p1</span>
    <span class="hljs-built_in">close</span>(p2[<span class="hljs-number">0</span>]); <span class="hljs-comment">// Ferme le read end de pipe p2</span>

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number_of_ping_pong; i++){
      <span class="hljs-keyword">char</span> buf;
      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">read</span>(p1[<span class="hljs-number">0</span>], &amp;buf, <span class="hljs-number">1</span>) != <span class="hljs-number">1</span>){
        <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"&lt;child - PID : %d&gt;  : send pong\n"</span>, getpid());
      <span class="hljs-built_in">write</span>(p2[<span class="hljs-number">1</span>], &amp;buf, <span class="hljs-number">1</span>);
    }

    <span class="hljs-built_in">close</span>(p1[<span class="hljs-number">0</span>]);
    <span class="hljs-built_in">close</span>(p2[<span class="hljs-number">1</span>]);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
  }
  <span class="hljs-comment">// Processus parent</span>
  <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">close</span>(p1[<span class="hljs-number">0</span>]); <span class="hljs-comment">// Ferme le read end de pipe p1</span>
    <span class="hljs-built_in">close</span>(p2[<span class="hljs-number">1</span>]); <span class="hljs-comment">// Ferme le write end de pipe p2</span>

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number_of_ping_pong; i++){
      sleep(<span class="hljs-number">10</span>);

      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"&lt;parent - PID : %d&gt;  : send ping\n"</span>, getpid());

      <span class="hljs-keyword">char</span> buf = <span class="hljs-string">'x'</span>;
      <span class="hljs-built_in">write</span>(p1[<span class="hljs-number">1</span>], &amp;buf, <span class="hljs-number">1</span>);

      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">read</span>(p2[<span class="hljs-number">0</span>], &amp;buf, <span class="hljs-number">1</span>) != <span class="hljs-number">1</span>){
        <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-built_in">close</span>(p1[<span class="hljs-number">1</span>]);
    <span class="hljs-built_in">close</span>(p2[<span class="hljs-number">0</span>]);

    wait(<span class="hljs-number">0</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
  }
}
</div></code></pre>
<h4 id="213-diagramme-uml-de-la-communication">2.1.3 Diagramme UML de la communication</h4>
<p>Le diagramme suivant illustre la communication entre le processus parent et le processus fils dans le programme pingpong :</p>
<p><img src="./images/PingPong.png" alt="Communication pingpong"></p>
<p>Ce diagramme montre comment les messages sont échangés entre le parent et l'enfant à travers deux pipes distincts. Le parent envoie &quot;ping&quot; via p1, et le fils répond avec &quot;pong&quot; via p2.</p>
<h3 id="22-programme-%22devine%22">2.2 Programme &quot;Devine&quot;</h3>
<p>Ce programme implémente un jeu de devinette où le processus parent tire un nombre aléatoire entre 1 et 100, et le processus fils doit le deviner en utilisant une approche dichotomique.</p>
<h4 id="221-description-du-programme">2.2.1 Description du programme</h4>
<p>Le processus parent génère un nombre aléatoire et le processus fils tente de le deviner. Après chaque tentative du fils, le parent répond si le nombre proposé est trop grand, trop petit ou correct. La communication s'effectue via deux pipes : un pour envoyer les propositions du fils au père, et l'autre pour transmettre les indices du père au fils.</p>
<h4 id="222-impl%C3%A9mentation">2.2.2 Implémentation</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/types.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/stat.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"user/user.h"</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_NUMBER 100</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_NUMBER 1</span>

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"Usage: devine &lt;number of tries (&gt; 0)&gt;\n"</span>);
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generate_random_number</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *number)</span> </span>{
  uint32 r, seed = uptime();
  srand(seed);
  r = rand();
  *number = r % (MAX_NUMBER - MIN_NUMBER + <span class="hljs-number">1</span>) + MIN_NUMBER;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span>
</span>{
  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) {
    usage();
  }
  <span class="hljs-keyword">int</span> tries = atoi(argv[<span class="hljs-number">1</span>]);
  <span class="hljs-keyword">if</span> (tries &lt;= <span class="hljs-number">0</span>) {
    usage();
  }

  <span class="hljs-keyword">int</span> max_tries = tries;

  <span class="hljs-keyword">int</span> p1[<span class="hljs-number">2</span>]; <span class="hljs-comment">// fils -&gt; père (guess)</span>
  <span class="hljs-keyword">int</span> p2[<span class="hljs-number">2</span>]; <span class="hljs-comment">// père -&gt; fils (number)</span>

  <span class="hljs-keyword">if</span> (pipe(p1) &lt; <span class="hljs-number">0</span> || pipe(p2) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"pipe error\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
  }
  <span class="hljs-keyword">int</span> pid = fork();
  <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"fork error\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
  }

  tries = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Processus père</span>
    <span class="hljs-built_in">close</span>(p1[<span class="hljs-number">1</span>]); <span class="hljs-comment">// Ferme l'écriture</span>
    <span class="hljs-built_in">close</span>(p2[<span class="hljs-number">0</span>]); <span class="hljs-comment">// Ferme la lecture</span>
    <span class="hljs-keyword">int</span> mystery;
    generate_random_number(&amp;mystery);

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&lt;parent - PID : %d&gt; : Game start - mystery number between 1 to 100 : %d\n"</span>,
      getpid(), mystery);

    <span class="hljs-keyword">int</span> guess, feedback;

    <span class="hljs-keyword">while</span>(tries &lt; max_tries) {
      <span class="hljs-comment">// lire le nombre proposé par le fils</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">read</span>(p1[<span class="hljs-number">0</span>], &amp;guess, <span class="hljs-keyword">sizeof</span>(guess)) != <span class="hljs-keyword">sizeof</span>(guess)) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"read error\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
      }
      tries++;
      <span class="hljs-keyword">if</span> (guess &gt; mystery) {
        feedback = <span class="hljs-number">1</span>; <span class="hljs-comment">// trop grand</span>
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"&lt;parent - PID : %d&gt; : number given %d higher than mystery %d\n"</span>,
                       getpid(), guess, mystery);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (guess &lt; mystery) {
        feedback = <span class="hljs-number">-1</span>; <span class="hljs-comment">// trop petit</span>
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"&lt;parent - PID : %d&gt; : number given %d lesser than mystery %d\n"</span>,
                       getpid(), guess, mystery);
      } <span class="hljs-keyword">else</span> {
        feedback = <span class="hljs-number">0</span>; <span class="hljs-comment">// gagné</span>
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"&lt;parent - PID : %d&gt; : number found %d == %d in %d %s!!!\n"</span>,
          getpid(), guess, mystery, tries,
          (tries &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">"tries"</span> : <span class="hljs-string">"try"</span>));
      }

      <span class="hljs-comment">// envoyer le feedback au fils</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">write</span>(p2[<span class="hljs-number">1</span>], &amp;feedback, <span class="hljs-keyword">sizeof</span>(feedback)) != <span class="hljs-keyword">sizeof</span>(feedback)) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"write error\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
      }
      <span class="hljs-keyword">if</span> (feedback == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-keyword">if</span> (tries == max_tries) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"&lt;parent - PID : %d&gt; : number not found in %d tries\n"</span>,
        getpid(), max_tries);
    }

    <span class="hljs-built_in">close</span>(p1[<span class="hljs-number">0</span>]);
    <span class="hljs-built_in">close</span>(p2[<span class="hljs-number">1</span>]);
    wait(<span class="hljs-number">0</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Processus fils</span>
    <span class="hljs-built_in">close</span>(p1[<span class="hljs-number">0</span>]);
    <span class="hljs-built_in">close</span>(p2[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">int</span> guess, feedback;
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = MIN_NUMBER, <span class="hljs-built_in">max</span> = MAX_NUMBER;
    <span class="hljs-keyword">while</span> (tries &lt; max_tries) {
      guess = (<span class="hljs-built_in">min</span> + <span class="hljs-built_in">max</span>) / <span class="hljs-number">2</span>;
      sleep(<span class="hljs-number">10</span>);
      tries++;
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&lt;child - PID : %d&gt; : send number (0 to 100) to parent --&gt; %d\n"</span>,
        getpid(), guess);

      <span class="hljs-comment">// envoyer le nombre proposé au père</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">write</span>(p1[<span class="hljs-number">1</span>], &amp;guess, <span class="hljs-keyword">sizeof</span>(guess)) != <span class="hljs-keyword">sizeof</span>(guess)) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"write error\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
      }

      <span class="hljs-comment">// lire le feedback du père</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">read</span>(p2[<span class="hljs-number">0</span>], &amp;feedback, <span class="hljs-keyword">sizeof</span>(feedback)) != <span class="hljs-keyword">sizeof</span>(feedback)) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"read error\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
      }

      <span class="hljs-keyword">if</span> (feedback == <span class="hljs-number">1</span>) {
        <span class="hljs-built_in">max</span> = guess - <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (feedback == <span class="hljs-number">-1</span>) {
        <span class="hljs-built_in">min</span> = guess + <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-built_in">close</span>(p1[<span class="hljs-number">1</span>]);
    <span class="hljs-built_in">close</span>(p2[<span class="hljs-number">0</span>]);
  }
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
}
</div></code></pre>
<h4 id="223-diagramme-uml-de-la-communication">2.2.3 Diagramme UML de la communication</h4>
<p>Le diagramme suivant illustre le processus de communication dans le jeu &quot;Devine&quot; :</p>
<p><img src="./images/Devine.png" alt="Communication Devine"></p>
<p>Ce diagramme montre comment le processus fils propose un nombre au processus parent, et comment le parent répond avec un indice pour guider le fils vers la bonne réponse.</p>
<h3 id="23-programme-%22oxo%22-morpion">2.3 Programme &quot;OXO&quot; (Morpion)</h3>
<p>Ce programme implémente un jeu de morpion (Tic-Tac-Toe) où trois processus communiquent entre eux : un arbitre (parent) et deux joueurs (fils).</p>
<h4 id="231-description-du-programme">2.3.1 Description du programme</h4>
<p>L'arbitre initialise le jeu, affiche le plateau, vérifie les conditions de victoire ou de match nul, et gère les tours des joueurs. Les joueurs A et B choisissent aléatoirement des positions libres sur le plateau et communiquent leurs choix à l'arbitre. Le jeu se déroule jusqu'à ce qu'un joueur gagne ou que le plateau soit rempli (match nul).</p>
<h4 id="232-impl%C3%A9mentation">2.3.2 Implémentation</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/types.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/stat.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"user/user.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/fcntl.h"</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOARD_SIZE 9</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EMPTY 9</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PLAYER_X -1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PLAYER_O 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WINNING_SUM 3</span>

<span class="hljs-comment">// Indice des pipes</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> READ 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRITE 1</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printBoard</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* board)</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BOARD_SIZE; i++) {
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }

    <span class="hljs-keyword">if</span> (board[i] == EMPTY) {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"_ "</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[i] == PLAYER_X) {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"X "</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[i] == PLAYER_O) {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"O "</span>);
    }

    <span class="hljs-keyword">if</span> ((i + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }
  }
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">checkWin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* board)</span> </span>{
  <span class="hljs-comment">// Regarde les lignes</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
    <span class="hljs-keyword">int</span> rowSum = board[i*<span class="hljs-number">3</span>] + board[i*<span class="hljs-number">3</span> + <span class="hljs-number">1</span>] + board[i*<span class="hljs-number">3</span> + <span class="hljs-number">2</span>];
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(rowSum) == WINNING_SUM) {
      <span class="hljs-keyword">return</span> rowSum / WINNING_SUM;
    }
  }

  <span class="hljs-comment">// Regarde les colonnes</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
    <span class="hljs-keyword">int</span> colSum = board[i] + board[i + <span class="hljs-number">3</span>] + board[i + <span class="hljs-number">6</span>];
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(colSum) == WINNING_SUM) {
      <span class="hljs-keyword">return</span> colSum / WINNING_SUM;
    }
  }

  <span class="hljs-comment">// Regarde les diagonales</span>
  <span class="hljs-keyword">int</span> diag1 = board[<span class="hljs-number">0</span>] + board[<span class="hljs-number">4</span>] + board[<span class="hljs-number">8</span>];
  <span class="hljs-keyword">int</span> diag2 = board[<span class="hljs-number">2</span>] + board[<span class="hljs-number">4</span>] + board[<span class="hljs-number">6</span>];

  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(diag1) == WINNING_SUM) {
    <span class="hljs-keyword">return</span> diag1 / WINNING_SUM;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(diag2) == WINNING_SUM) {
    <span class="hljs-keyword">return</span> diag2 / WINNING_SUM;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isDraw</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* board)</span> </span>{
  <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BOARD_SIZE; i++) {
    sum += board[i];
  }

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(sum) == <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isGameOver</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* board)</span> </span>{
  <span class="hljs-keyword">return</span> (checkWin(board) != <span class="hljs-number">0</span>) || isDraw(board);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getValidRandomMove</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* board)</span> </span>{
  <span class="hljs-keyword">int</span> emptyCells[BOARD_SIZE];
  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// Trouver les cases vides</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BOARD_SIZE; i++) {
    <span class="hljs-keyword">if</span> (board[i] == EMPTY) {
      emptyCells[count++] = i;
    }
  }

  <span class="hljs-comment">// Si aucune case vide, retourner -1</span>
  <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  <span class="hljs-comment">// Générer un nombre aléatoire</span>
  uint32 r, seed = uptime();
  srand(seed);
  r = rand();

  <span class="hljs-comment">// Choisir une case vide aléatoire</span>
  <span class="hljs-keyword">int</span> randomIndex = r % count;
  <span class="hljs-keyword">return</span> emptyCells[randomIndex];
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">playAsReferee</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* board, <span class="hljs-keyword">int</span> pipeToA[<span class="hljs-number">2</span>], <span class="hljs-keyword">int</span> pipeFromA[<span class="hljs-number">2</span>],
                   <span class="hljs-keyword">int</span> pipeToB[<span class="hljs-number">2</span>], <span class="hljs-keyword">int</span> pipeFromB[<span class="hljs-number">2</span>])</span> </span>{
  <span class="hljs-keyword">int</span> currentPlayer = PLAYER_X; <span class="hljs-comment">// X commence</span>
  <span class="hljs-keyword">int</span> <span class="hljs-built_in">move</span>;
  <span class="hljs-keyword">int</span> winner = <span class="hljs-number">0</span>;

  printBoard(board);

  <span class="hljs-keyword">while</span> (!isGameOver(board)) {
    <span class="hljs-keyword">if</span> (currentPlayer == PLAYER_X) {
      <span class="hljs-comment">// Demander le coup du joueur X</span>
      <span class="hljs-built_in">write</span>(pipeToA[WRITE], board, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * BOARD_SIZE);
      <span class="hljs-built_in">read</span>(pipeFromA[READ], &amp;<span class="hljs-built_in">move</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">move</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">move</span> &lt; BOARD_SIZE &amp;&amp; board[<span class="hljs-built_in">move</span>] == EMPTY) {
        board[<span class="hljs-built_in">move</span>] = PLAYER_X;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Joueur A : à vous de joueur! Position %d\n"</span>, <span class="hljs-built_in">move</span> + <span class="hljs-number">1</span>);
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Demander le coup du joueur O</span>
      <span class="hljs-built_in">write</span>(pipeToB[WRITE], board, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * BOARD_SIZE);
      <span class="hljs-built_in">read</span>(pipeFromB[READ], &amp;<span class="hljs-built_in">move</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">move</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">move</span> &lt; BOARD_SIZE &amp;&amp; board[<span class="hljs-built_in">move</span>] == EMPTY) {
        board[<span class="hljs-built_in">move</span>] = PLAYER_O;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Joueur B : à vous de joueur! Position %d\n"</span>, <span class="hljs-built_in">move</span> + <span class="hljs-number">1</span>);
      }
    }

    printBoard(board);

    currentPlayer = -currentPlayer;

    sleep(<span class="hljs-number">10</span>);
  }

  winner = checkWin(board);
  <span class="hljs-keyword">if</span> (winner == PLAYER_X) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Bravo Joueur A: vous avez gagné la partie!\n"</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (winner == PLAYER_O) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Bravo Joueur B: vous avez gagné la partie!\n"</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"C'est un match nul!\n"</span>);
  }

  <span class="hljs-comment">// Envoyer un signal de fin aux joueurs</span>
  <span class="hljs-keyword">int</span> endSignal = <span class="hljs-number">-99</span>;
  <span class="hljs-built_in">write</span>(pipeToA[WRITE], &amp;endSignal, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
  <span class="hljs-built_in">write</span>(pipeToB[WRITE], &amp;endSignal, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">playAsPlayerA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pipeToParent[<span class="hljs-number">2</span>], <span class="hljs-keyword">int</span> pipeFromParent[<span class="hljs-number">2</span>])</span> </span>{
  <span class="hljs-keyword">int</span> board[BOARD_SIZE];
  <span class="hljs-keyword">int</span> <span class="hljs-built_in">move</span>;

  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">read</span>(pipeFromParent[READ], board, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * BOARD_SIZE) &lt;= <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>] == <span class="hljs-number">-99</span>) {
      <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-built_in">move</span> = getValidRandomMove(board);
    <span class="hljs-built_in">write</span>(pipeToParent[WRITE], &amp;<span class="hljs-built_in">move</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">playAsPlayerB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pipeToParent[<span class="hljs-number">2</span>], <span class="hljs-keyword">int</span> pipeFromParent[<span class="hljs-number">2</span>])</span> </span>{
  <span class="hljs-keyword">int</span> board[BOARD_SIZE];
  <span class="hljs-keyword">int</span> <span class="hljs-built_in">move</span>;

  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">read</span>(pipeFromParent[READ], board, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * BOARD_SIZE) &lt;= <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>] == <span class="hljs-number">-99</span>) {
      <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-built_in">move</span> = getValidRandomMove(board);
    <span class="hljs-built_in">write</span>(pipeToParent[WRITE], &amp;<span class="hljs-built_in">move</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
  }
}


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span>
</span>{
  <span class="hljs-keyword">int</span> board[BOARD_SIZE];
  <span class="hljs-keyword">int</span> pipeParentToA[<span class="hljs-number">2</span>], pipeAToParent[<span class="hljs-number">2</span>];
  <span class="hljs-keyword">int</span> pipeParentToB[<span class="hljs-number">2</span>], pipeBToParent[<span class="hljs-number">2</span>];
  <span class="hljs-keyword">int</span> pid1, pid2;

  <span class="hljs-comment">// Créer le tableau de jeu</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BOARD_SIZE; i++) {
    board[i] = EMPTY;
  }

  <span class="hljs-comment">// Créer les pipes</span>
  <span class="hljs-keyword">if</span> (pipe(pipeParentToA) &lt; <span class="hljs-number">0</span> || pipe(pipeAToParent) &lt; <span class="hljs-number">0</span> ||
      pipe(pipeParentToB) &lt; <span class="hljs-number">0</span> || pipe(pipeBToParent) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Erreur lors de la création des pipes\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
  }

  <span class="hljs-comment">// Joueur (A - X)</span>
  pid1 = fork();
  <span class="hljs-keyword">if</span> (pid1 &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Erreur lors de la création du joueur X\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">if</span> (pid1 == <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Child process (Joueur A - X)</span>
    <span class="hljs-built_in">close</span>(pipeParentToA[WRITE]);
    <span class="hljs-built_in">close</span>(pipeAToParent[READ]);
    <span class="hljs-built_in">close</span>(pipeParentToB[READ]);
    <span class="hljs-built_in">close</span>(pipeParentToB[WRITE]);
    <span class="hljs-built_in">close</span>(pipeBToParent[READ]);
    <span class="hljs-built_in">close</span>(pipeBToParent[WRITE]);

    playAsPlayerA(pipeAToParent, pipeParentToA);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
  }

  <span class="hljs-comment">// Joueur (B - O)</span>
  pid2 = fork();
  <span class="hljs-keyword">if</span> (pid2 &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Erreur lors de la création du joueur B\n"</span>);
    kill(pid1);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">if</span> (pid2 == <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Child process (Joueur B - O)</span>
    <span class="hljs-built_in">close</span>(pipeParentToB[WRITE]);
    <span class="hljs-built_in">close</span>(pipeBToParent[READ]);
    <span class="hljs-built_in">close</span>(pipeParentToA[READ]);
    <span class="hljs-built_in">close</span>(pipeParentToA[WRITE]);
    <span class="hljs-built_in">close</span>(pipeAToParent[READ]);
    <span class="hljs-built_in">close</span>(pipeAToParent[WRITE]);

    playAsPlayerB(pipeBToParent, pipeParentToB);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
  }

  <span class="hljs-comment">// Parent process (Joueur - Referee)</span>
  <span class="hljs-built_in">close</span>(pipeParentToA[READ]);
  <span class="hljs-built_in">close</span>(pipeAToParent[WRITE]);
  <span class="hljs-built_in">close</span>(pipeParentToB[READ]);
  <span class="hljs-built_in">close</span>(pipeBToParent[WRITE]);

  playAsReferee(board, pipeParentToA, pipeAToParent, pipeParentToB, pipeBToParent);

  <span class="hljs-comment">// Attendre la fin des joueurs</span>
  wait(<span class="hljs-number">0</span>);
  wait(<span class="hljs-number">0</span>);

  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
}
</div></code></pre>
<h4 id="233-diagrammes-uml-de-la-communication">2.3.3 Diagrammes UML de la communication</h4>
<p>Plusieurs diagrammes UML ont été conçus pour illustrer les différentes phases du jeu OXO :</p>
<ol>
<li><strong>Initialisation du jeu</strong> : Création des pipes et des processus</li>
</ol>
<p><img src="./images/OXO_Initialisation.png" alt="OXO Initialisation"></p>
<ol start="2">
<li><strong>Tour du Joueur A</strong> : Communication entre l'arbitre et le joueur A</li>
</ol>
<p><img src="./images/OXO_TourA.png" alt="OXO Tour Joueur A"></p>
<ol start="3">
<li><strong>Tour du Joueur B</strong> : Communication entre l'arbitre et le joueur B</li>
</ol>
<p><img src="./images/OXO_TourB.png" alt="OXO Tour Joueur B"></p>
<ol start="4">
<li><strong>Fin de partie</strong> : Signalement de la fin du jeu aux joueurs</li>
</ol>
<p><img src="./images/OXO_Fin.png" alt="OXO Fin de partie"></p>
<p>Ces diagrammes montrent comment les trois processus communiquent entre eux via des pipes, et comment l'arbitre gère le déroulement du jeu.</p>
<h2 id="3-analyse-et-discussion">3. Analyse et discussion</h2>
<h3 id="31-utilisation-des-pipes-pour-la-communication-inter-processus">3.1 Utilisation des pipes pour la communication inter-processus</h3>
<p>Les pipes sont un mécanisme fondamental de communication inter-processus dans les systèmes Unix. Dans nos programmes, nous avons utilisé des pipes unidirectionnels pour établir des canaux de communication entre les processus. Chaque pipe possède une extrémité de lecture et une extrémité d'écriture, ce qui permet une communication à sens unique.</p>
<p>Pour établir une communication bidirectionnelle, comme dans le programme pingpong, nous avons utilisé deux pipes : un pour envoyer des messages du parent vers l'enfant, et un autre pour envoyer des messages de l'enfant vers le parent.</p>
<h3 id="32-gestion-des-descripteurs-de-fichiers">3.2 Gestion des descripteurs de fichiers</h3>
<p>La fermeture des descripteurs de fichiers non utilisés est une pratique importante dans la programmation système. Dans nos programmes, nous avons fermé systématiquement les extrémités des pipes que nous n'utilisions pas. Cette pratique permet d'éviter les fuites de ressources et les problèmes de synchronisation.</p>
<h3 id="33-synchronisation-des-processus">3.3 Synchronisation des processus</h3>
<p>Dans les programmes que nous avons développés, la synchronisation entre les processus est assurée par les opérations de lecture et d'écriture sur les pipes. Lorsqu'un processus tente de lire à partir d'un pipe vide, il est bloqué jusqu'à ce que des données soient disponibles. De même, lorsqu'un processus tente d'écrire dans un pipe plein, il est bloqué jusqu'à ce que de l'espace soit disponible.</p>
<p>Cette synchronisation naturelle est particulièrement visible dans le programme pingpong, où le parent et l'enfant s'attendent mutuellement pour échanger des messages.</p>
<h2 id="4-conclusion">4. Conclusion</h2>
<p>Ce TP nous a permis d'explorer en profondeur les mécanismes de communication inter-processus à travers l'utilisation des pipes dans le système d'exploitation XV6. Les trois programmes que nous avons développés illustrent différentes façons d'utiliser les pipes pour établir des communications entre les processus.</p>
<p>Le programme pingpong démontre une communication bidirectionnelle simple entre un processus parent et son enfant. Le programme devine met en œuvre une communication plus complexe où les processus échangent des données structurées pour jouer à un jeu de devinette. Enfin, le programme OXO pousse le concept encore plus loin en orchestrant la communication entre trois processus pour simuler un jeu de morpion.</p>
<p>À travers ces implémentations, nous avons acquis une compréhension pratique des concepts fondamentaux des IPC dans les systèmes Unix, notamment la création et l'utilisation des pipes, la gestion des descripteurs de fichiers, et la synchronisation des processus.</p>

</body>
</html>
